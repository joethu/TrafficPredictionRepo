# NOTE 2016/6/2: remove orders whose start district hash is not in given cluster map, which means
# our algorithm doesn't consider the orders between disctrict in and out of the given clusters

import Utils
import csv

UNANSWERRED_DRIVER_ID = "NULL"
g_removed_orders = dict() #key is order_id, value is a list of flaw descriptions

# some string literals
DEMAND_KEY = "demand"
SUPPLY_KEY = "supply"
GAP_KEY = "gap"


def record_removed_orders(order_id,error_msg):
    if order_id in g_removed_orders.keys():
        g_removed_orders[order_id].append(error_msg)
    else:
        g_removed_orders[order_id] = [error_msg]
    Utils.log_debug("Order removed - " + order_id + ": " + error_msg)

class Order:
    def __init__(self,_order_id,_driver_id,_passenger_id,_start_district_id,_dest_district_id,_price,_date,_time_slice_id):
        self.order_id            = _order_id
        self.driver_id         =    _driver_id
        self.passenger_id    = _passenger_id
        self.start_district_id    = _start_district_id
        self.dest_district_id        = _dest_district_id
        self.price    = _price
        self.date     = _date
        self.time_slice_id = _time_slice_id
        self.is_unanswerred = _driver_id==UNANSWERRED_DRIVER_ID # order not answerred
        
    #Function: convert order information to a string
    # input: order (Class: OrderData.Order)
    # output: string to be written to file, generated by connecting necessary
    #         order information with the dedicated delimiter  
    def order_to_str(self):
        return Utils.GLOBAL_DELIMITER.join([str(self.start_district_id),str(self.date),str(self.time_slice_id),str(self.dest_district_id),str(self.driver_id),str(self.passenger_id),str(self.price)])


#Class: order data in a day
class OrderData :
    def __init__(self,data_date,cluster_map):
        #DORDERS IN A DAY: dict(district_id -> dict(time_slice_id->list_orders))
        self.order_data = self.gen_order_dict_by_district(cluster_map)
        #DEMAND-SUPPLY IN A DAY: dict(district_id -> dict(time_slice_id->[demand,supply,gap]))
        self.ds_data = self.gen_ds_dict_by_district(cluster_map)
        self.date = data_date
        self.cls_map = cluster_map
        
    # SOME HELPER FOR INITIALIZATION
    # GENERATE an empty dictionary to store orders by time slice
     # return: dict(time_slice_id->empty_list_orders)
    def gen_order_dict_by_time_slice(self):
        empty_dict = dict()
        for time_slice in range(1,Utils.TIME_SLICE_NUMBER_DAY + 1):
            empty_dict[time_slice] = []    
        return empty_dict
    
    # GENERATE an empty dictionary to store orders by district
     # return: dict(district_id -> dict(time_slice_id->empty_list_orders))
    def gen_order_dict_by_district(self,cluster_map):
        empty_dict = dict()
        for district_id in list(cluster_map.values()):
            empty_dict[district_id] = self.gen_order_dict_by_time_slice()
        return empty_dict
     
    # GENERATE an empty dictionary to store demand-supply-gap by time slice
     # return: dict(time_slice_id->empty_list_demand_supply_gap)
    def gen_ds_dict_by_time_slice(self):
        empty_dict = dict()
        for time_slice in range(1,Utils.TIME_SLICE_NUMBER_DAY + 1):
            empty_dict[time_slice] = []
        return empty_dict
    
    # GENERATE an empty dictionary to store demand-supply-gap by district
     # return: dict(district_id -> dict(time_slice_id->empty_list_demand_supply_gap))
    def gen_ds_dict_by_district(self,cluster_map):
        empty_dict = dict()
        for district_id in list(cluster_map.values()):
            empty_dict[district_id] = self.gen_ds_dict_by_time_slice()
        return empty_dict

    # LOAD ORDER DATA BY DAY 
     # input: orders in file_path must be from the day of order_date
     # return: dict(district_id -> dict(time_slice_id->list_orders))
    def load_orders_by_day(self,file_path):
        self.order_data = self.gen_order_dict_by_district(self.cls_map)
        reader = csv.reader(open(file_path),delimiter=Utils.GLOBAL_DELIMITER)
        for order_raw in reader:
            order_id = order_raw[0]
            start_district_id = Utils.dist_hash_to_id(order_raw[3],self.cls_map)
            if Utils.DEBUG_MODE and start_district_id == Utils.DEFAULT_DISTRICT_ID:
                record_removed_orders(order_id,"Start district not in cluster map: " + order_raw[3])
            if start_district_id != Utils.DEFAULT_DISTRICT_ID:
                dest_district_id = Utils.dist_hash_to_id(order_raw[4],self.cls_map)
                date_time = order_raw[6].split(Utils.SECONDARY_DELIMITER)
                if self.date != date_time[0]:
                    if Utils.DEBUG_MODE:
                        record_removed_orders(order_id,"Order date unmatched: " + date_time[0])
                    continue
                time_slice_id = Utils.get_time_slice_id(date_time[1])
                if Utils.is_valid_time_slice_id(time_slice_id):
                    order = Order(order_id,order_raw[1],order_raw[2],start_district_id,dest_district_id,order_raw[5],self.date,time_slice_id)
                    self.order_data[start_district_id][time_slice_id].append(order)
                else:
                    if Utils.DEBUG_MODE:
                        record_removed_orders(order_id,"Invalid time stamp: " + date_time[1])

    # FUNCTIONS FOR DATA PROCESSING
    # CALCULATE THE DEMAND SUPPLY GAP WITHIN A PERIOD
     # input: list of orders (Class Order)
     # return: list [demand, supply, gap]
     # note: here we assume orders are from the same time slice, hence no bother checking it again
    def calc_demand_supply(self,list_orders):
        demand = len(list_orders)
        gap = 0;
        for order in list_orders:
            if order.is_unanswerred:
                gap += 1
        supply = demand - gap
        return {DEMAND_KEY:demand,SUPPLY_KEY:supply,GAP_KEY:gap}
    
    # CALCULATE THE DEMAND SUPPLY GAP OF ORDERS FOR ALL CLUSTERS IN ALL TIME SLICES IN A DAY
     # return dict(district_id -> dict(time_slice_id->[demand,supply,gap]))
    def calc_demand_supply_by_day(self):
        self.ds_data = self.gen_ds_dict_by_district(self.cls_map)
        for district_id in sorted(self.order_data.keys()):
            dict_ds_by_time_slice = dict()
            for time_slice_id in sorted(self.order_data[district_id].keys()):
                dict_ds_by_time_slice[time_slice_id] = self.calc_demand_supply(self.order_data[district_id][time_slice_id]) 
            self.ds_data[district_id] = dict_ds_by_time_slice
        
    # Function: load demand and supply by day
     # input: demand_supply info in file_path must be from the day of "date"
     # return: dict(district_id -> dict(time_slice_id->[d s g]))
    def load_demand_supply_by_day(self,file_path):
        self.ds_data = self.gen_ds_dict_by_district(self.cls_map)
        reader = csv.reader(open(file_path),delimiter=Utils.GLOBAL_DELIMITER)
        for [district_id,str_date_time,demand,supply,gap] in reader:
        # 1	2016-01-24-139	89	86	3
            [ds_date,ds_time_slice_id] = Utils.split_date_time_slice(str_date_time)
            if ds_date != self.date:
                Utils.log_debug("Demand-Supply date unmatched: " + ds_date)
                continue
            district_id = int(district_id)
            if not district_id in self.ds_data.keys():
                Utils.log_debug("Demand-Supply district_id unmatched: " + str(district_id))
                continue
            if not ds_time_slice_id in self.ds_data[district_id].keys():
                Utils.log_debug("Demand-Supply time_slice_id unmatched: " + str(ds_time_slice_id))
                continue
            self.ds_data[district_id][ds_time_slice_id] = {DEMAND_KEY:demand,SUPPLY_KEY:supply,GAP_KEY:gap}
    
    #Function: write orders of a day to file
    def export_orders_by_day(self,file_path):
        file = open(file_path,'w')
        need_return_char = False
        for district_id in sorted(self.order_data.keys()):
            for time_slice_id in sorted(self.order_data[district_id].keys()):
                str_to_write = ""
                for order in self.order_data[district_id][time_slice_id]:
                    if need_return_char:
                        str_to_write += Utils.RETURN_CHAR                
                    str_to_write += order.order_to_str()
                    need_return_char = True
                file.write(str_to_write) # write once per time_slice
        file.close()
    
    #Function: write demand and supply of a day to file
     #.gap_only: bool, indicates whether to export the gap only or [demand,supply,gap]
    def export_ds_by_day(self,file_path,gap_only):
        file = open(file_path,'w')
        need_return_char = False
        for district_id in sorted(self.ds_data.keys()):
            str_to_write = ""
            for time_slice_id in sorted(self.ds_data[district_id].keys()):
                if need_return_char:
                    str_to_write += Utils.RETURN_CHAR
                date_time_slice = Utils.connect_date_time_slice(self.date,time_slice_id)
                str_to_connect = [str(district_id),date_time_slice]
                demand_supply = self.ds_data[district_id][time_slice_id]
                if gap_only:
                    str_to_connect.append(str(demand_supply[GAP_KEY]))
                else:
                    str_to_connect.append(str(demand_supply[DEMAND_KEY]))
                    str_to_connect.append(str(demand_supply[SUPPLY_KEY]))
                    str_to_connect.append(str(demand_supply[GAP_KEY]))
                str_to_write += Utils.GLOBAL_DELIMITER.join(str_to_connect)
                need_return_char = True
            file.write(str_to_write) # write once per district
        file.close()
            